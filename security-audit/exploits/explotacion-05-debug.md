# Explotación 5: Debug Mode Enabled

**Auditor:** DAVID H. CUEVAS SALGADO
**Fecha:** 29/11/2025 20:11  
**Vulnerabilidad:** Information Disclosure - Debug Mode  
**Severidad:** MEDIA (CVSS 5.0)

---

## Descripción del Exploit

La aplicación está ejecutándose con \debug=True\, lo que expone el debugger interactivo de Werkzeug y revela información sensible del sistema mediante stack traces completos.

## Código Vulnerable

\\\python
# vulnerable_flask_app.py línea 145
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
\\\

## Información Expuesta

### 1. Stack Traces Completos
- Código fuente de archivos Python
- Números de línea exactos
- Variables locales y sus valores
- Estructura de la aplicación

### 2. Rutas del Sistema
\\\
/app/vulnerable_flask_app.py
/usr/local/lib/python3.11/site-packages/flask/...
\\\

### 3. Headers Informativos
\\\
Server: Werkzeug/2.3.7 Python/3.11.x
\\\

### 4. Debugger Interactivo
- Consola Python accesible
- Recursos del debugger (\__debugger__\)
- Capacidad de ejecutar código arbitrario en los frames
- Funciones \dump()\ para inspección de objetos

## Pasos de Explotación

### Método 1: Forzar error para ver stack trace
1. Navegar a http://localhost:5000/login
2. Ingresar payload que cause error SQL:
   - Username: \dmin\
   - Password: \' OR '1'='1' UNION SELECT null--\
3. Servidor responde con error 500
4. Stack trace completo visible en el navegador

### Método 2: Ejecutar script automatizado
\\\ash
python security-audit/exploits/05_debug_mode.py
\\\

## Evidencia

- Script: \security-audit/exploits/05_debug_mode.py\
- Stack traces capturados
- Código fuente visible en errores
- Rutas del servidor expuestas
- Versiones de software reveladas
- Werkzeug Debugger interactivo accesible

## Impacto Demostrado

### Confidencialidad ALTA
- **Código fuente:** Lógica de negocio completamente expuesta
- **Estructura:** Arquitectura de la aplicación revelada
- **Rutas absolutas:** Paths del sistema de archivos
- **Dependencias:** Versiones exactas de librerías
- **Variables:** Contenido de variables locales visible

### Integridad MEDIA
- **RCE potencial:** Debugger interactivo puede ejecutar código Python
- **Bypass de seguridad:** Información para evadir controles

### Disponibilidad BAJA
- **Performance:** Stack traces hacen más lenta la respuesta
- **DoS:** Errores repetidos pueden degradar el servicio

## Ejemplos Reales de Información Expuesta

### Stack Trace Completo
\\\
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/flask/app.py", line 2213, in __call__
    return self.wsgi_app(environ, start_response)
  File "/app/vulnerable_flask_app.py", line 53, in login
    user = conn.execute(query).fetchone()
sqlite3.OperationalError: SELECTs to the left and right of UNION do not have the same number of result columns
\\\

### Código Fuente Visible
\\\python
# Línea 53 en vulnerable_flask_app.py
user = conn.execute(query).fetchone()
\\\

### Rutas del Sistema
\\\
/app/vulnerable_flask_app.py
/usr/local/lib/python3.11/site-packages/flask/app.py
/usr/local/lib/python3.11/sqlite3/dbapi2.py
\\\

### Mensaje del Debugger
\\\
The debugger caught an exception in your WSGI application.
You can execute arbitrary Python code in the stack frames.
dump() shows all variables in the frame
dump(obj) dumps all that's known about the object
\\\

## Vectores de Ataque Adicionales

1. **Reconnaissance:** Mapear toda la estructura de la aplicación
2. **Credential Harvesting:** Buscar secrets, API keys en código
3. **Vulnerability Chaining:** Combinar con otras vulnerabilidades
4. **Social Engineering:** Usar información técnica para ataques dirigidos
5. **Code Execution:** Potencial RCE mediante el debugger interactivo

## Recomendaciones

### Solución 1: Desactivar debug en producción
\\\python
import os

DEBUG = os.environ.get('FLASK_ENV') == 'development'
app.run(host='0.0.0.0', port=5000, debug=DEBUG)
\\\

### Solución 2: Usar variables de entorno
\\\ash
# Archivo .env
FLASK_ENV=production
FLASK_DEBUG=0
\\\

\\\python
# En el código
from dotenv import load_dotenv
load_dotenv()

app.run(
    host='0.0.0.0',
    port=5000,
    debug=os.getenv('FLASK_DEBUG', 'False') == 'True'
)
\\\

### Solución 3: Manejo de errores personalizado
\\\python
@app.errorhandler(500)
def internal_error(error):
    app.logger.error(f'Server Error: {error}')
    return render_template('500.html'), 500

@app.errorhandler(Exception)
def handle_exception(e):
    app.logger.error(f'Unhandled Exception: {e}')
    return render_template('error.html', error='Internal Server Error'), 500
\\\

### Solución 4: Logging seguro
\\\python
import logging
from logging.handlers import RotatingFileHandler

if not app.debug:
    handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=3)
    handler.setLevel(logging.ERROR)
    app.logger.addHandler(handler)
\\\

### Solución 5: Configuración por entorno
\\\python
class Config:
    DEBUG = False
    TESTING = False

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

# Usar según entorno
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig
}

app.config.from_object(config[os.getenv('FLASK_ENV', 'production')])
\\\

---

**Status:** EXPLOTACIÓN EXITOSA

